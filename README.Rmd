---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  dpi = 300
)
```

# Zoning for Autonomous Vehicles

<!-- badges: start -->
<!-- badges: end -->

The goal of zav (Zoning for Autonomous Vehicles) is to show the implementation of the problem instance generation and simulation experiment conducted for the project.

## Installation

You can install the development version of zav from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
# note that there is a GitHub only dependency
# devtools::install_github("cuhklinlab/SWKM")
devtools::install_github("Rosenkrands/zav")
```

## Instance generation

To generate a problem instance we can utilize the `generate_2d_instance` function.

```{r example}
library(zav)
library(ggplot2)
library(dplyr)

instance <- generate_2d_instance(no_of_points = 100)
# plot_point(instance = instance)
ggplot(instance$data) +
    geom_point(aes(x,y,size=`Arrival rate`),
                        shape = 21, fill = alpha("black", .2)) +
    theme_void()
```

## Zoning solutions

### Weighted K-Means

The below code chunk shows how we can utilize the `solve_wkmeans` function to generate a solution for our problem instance.

```{r solution}
solution_wkm <- solve_wkmeans(instance, no_of_centers = 5, type = "swkm")
plot_bases(solution = solution_wkm)
```

### Genetic Algorithm

The below chunk shows how we can utilize the `solve_ga` function to generate a solution for our problem instance.

First we need to precalculate centroids to use as input for the GA.

```{r, cache=T}
centroids <- grid_centroids(instance, dimension = 5)
```

Having now the centroids and distances between demand points and centroids, we are able to give this as input for the GA.
As a default the GA will have a maximum of 10 iterations for demonstration purposes, in reality we would have a much higher number of iterations. 

```{r, cache=T}
solution <- solve_ga(instance, centroids, no_of_centers = 5, obj = "SAFE")
```

```{r}
plot_bases(solution)
```

## Simulation

Here it is shown how you can make a simulation based on the solution just found:

```{r simulation, cache = T}
#' The below line is for testing purposes
#' solution = solution; seed = 1;n_replications = 1;flight = "zoned";max_dist = 1000000;LOS = 600;warmup = 0;speed_agent = .25;verbose = F
simulation_result <- simulation(
  solution = solution_wkm,
  seed = 1,
  n_replications = 1,
  flight = "zoned",
  queue = T,
  max_dist = 1000000,
  LOS = 600,
  warmup = 0,
  speed_agent = .25,
  verbose = F
)
```

```{r}
# simulation_result$metrics[[1]]$response_time_performance
```


```{r distances, fig.dim=c(8,3)*1.1}
simulation_result$metrics[[1]]$distances %>%
  ggplot(aes(x = time, 
             y = distance,
             color = paste0(id1,'-',id2))) +
  geom_line() +
  labs(color = "Pair") +
  theme(legend.position = "none")
```

### Free-flight/Soft zoning

As an argument to the simulation function we have `flight` that together with the `max_dist` argument allow the user to obtain simulation results from a "Free-flight" setup.
Here we will give a brief introduction to the concept.

If we set `fligth = "free"` and `max_dist` arbitrarily large any UAV would be able to service any demand. This is what we would refer to as free-flight.

However when any UAV can service any demand then mean response will suffer from long travel distances.
Therefore we propose using the following scheme to decide on a maximum distance for the service area

$\text{r} = \text{dist}_\text{max} + \alpha \cdot \text{number of UAVs}$

where $\alpha$ denotes the scaling factor and $\text{dist}_\text{max}$ denotes the maximum distance between a demand point and its base location.

To further illustrate let us consider the following situation.

```{r}
instance <- generate_2d_instance(no_of_points = 40)
solution <- solve_wkmeans(instance, no_of_centers = 4, type = "swkm")

plot_bases(solution) + coord_fixed()
```

We can the illustrate the service area for different values of $\alpha$ as follows.

```{r, echo = F, message=F}
centroids <- solution$instance %>%
    select(`Centroid id`, x.centroid, y.centroid) %>%
    distinct() %>%
    mutate(r = (solution$instance %>%
      mutate(distance = sqrt((x - x.centroid)^2 + (y - y.centroid)^2)) %>%
      summarise(distance = max(distance)))$distance
    )

  ggplot(solution$instance) +
    ggforce::geom_circle(
      data = centroids %>% 
        left_join(tibble(n = c(0,0.2,0.5)), by = character()) %>%
        mutate(r = r + n*4,
               `Scaling factor` = factor(n)),
      aes(x0 = x.centroid, y0 = y.centroid, r = r, fill = `Centroid id`, linetype = `Scaling factor`),
      alpha = .1, color = "grey"
    ) +
    geom_segment(aes(x = x, y = y, xend = x.centroid, yend = y.centroid),
                 color = "gray") +
    geom_point(aes(x,y, fill = `Centroid id`, size = `Arrival rate`, alpha = .2),
                        shape = 21, color = "black") +
    geom_point(
      data = centroids,
      aes(x.centroid, y.centroid), shape = 15, size = 2
    ) +
    theme_void() + coord_fixed()
```

## Experiment Results

To get analyze the results from the experiment conducted for the project we do the following.

```{r}
results <- experiment_results()
```

The `results` variable is a list of 3 `tibbles` containing information about instances, solutions and simulations respectively.

### Instances

If we take a look at the instances first we can see that there is a total of `r nrow(results$instance)` instances.
These are distributed across the two arrival rate variances as seen below.

```{r, message = F}
results$instance |> 
  group_by(`Arrival rate distribution`, `Arrival rate variance`) |> 
  summarise(n = n())
```

### Solutions

Taking a look at the solutions we see that there are a total of `r nrow(results$solution)` solutions.
These are distributed across:

* `Solution method` that have `r nrow(unique(results$solution[, "Solution method"]))` levels: `r unique(results$solution[, "Solution method"][[1]])`.
<!-- * `Number of UAVs` that have `r nrow(unique(results$solution[, "Number of UAVs"]))` levels: `r unique(results$solution[, "Number of UAVs"][[1]])`. -->

#### Solution comparsion

If we start by comparing ga-tot and wkm-swkm we see that the latter is able to outperform the first.

```{r, echo=F, message=F, fig.dim=c(8,3)*1.1}
results$solution |> 
  filter(`Solution method` != "ga-safe") |> 
  group_by(`Solution method`, `Arrival rate variance`, `Arrival rate distribution`, `Number of UAVs`) |> 
  summarise(sd = sd(TOT), TOT = mean(TOT)) |> 
  ggplot(aes(x = `Arrival rate variance`, y = TOT, group = `Solution method`, color = `Solution method`)) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin = TOT - sd, ymax = TOT + sd), width = .05)
```

### Simulations

Looking at the simulation results we can see how the utilization is affected by the queuing strategy.
First we can take a look at the zoned solution approach.

```{r, echo=F, message=F, utilization, fig.dim=c(8,3)*1.1}
results$simulation %>%
  select(`Instance id`, `Arrival rate distribution`, `Arrival rate variance`, `Solution method`, `Number of UAVs`, `Flight configuration`, `Queue strategy`, utilization) %>%
  filter(`Solution method` == "wkm-swkm", `Flight configuration` == "Zoned",
                `Arrival rate distribution` == "uniform") %>%
  transmute(group = paste0(`Instance id`, "-", `Queue strategy`), `Instance id`, `Queue strategy`, `Arrival rate variance`, utilization) %>%
  tidyr::unnest(cols = utilization) %>%
  group_by(hours, `Queue strategy`, `Arrival rate variance`) %>%
  summarise(min_util = min(utilization), max_util = max(utilization), mean_util = mean(utilization)) %>%
  ggplot(aes(x= hours, group = `Queue strategy`)) +
  geom_line(aes(y = mean_util, color = `Queue strategy`)) +
  geom_ribbon(aes(ymin = min_util, ymax = max_util, fill = `Queue strategy`), alpha = .4) +
  scale_y_continuous(limits = c(0,1)) +
  facet_wrap(~`Arrival rate variance`, labeller = label_both)
```

If we compare with the zoned solution approach with a free-flight approach we see that the utilization go to 1 with the FCFS queue.

Looking at the simulation performance measures mean response and ploss, given the no queue strategy, it would seem that we are giving up some response time to lower the ploss for $\alpha = 0$.
But for other values of $\alpha$ the performance are worse of overall.

```{r queue_no, echo=F, message=F, fig.dim=c(8,3)*1.1}
results$simulation |> 
  filter(`Arrival rate distribution` == "uniform", 
                `Queue strategy` == "No queue",
                `Number of UAVs` == "high") |> 
  tidyr::pivot_longer(cols = c(`Mean response`, Ploss), names_to = "Measure") |> 
  mutate(Measure = factor(Measure, levels = c("Mean response", "Ploss"))) |>
  group_by(Measure,`Arrival rate variance`,`Flight configuration`, `Number of UAVs`) |> 
  summarise(error = qt(.975, df = n() - 1)*sd(value)/sqrt(n()),
            value = mean(value)) |> 
  ggplot(aes(x = `Arrival rate variance`, y = value, fill = `Flight configuration`)) +
  geom_col(position = position_dodge(.9)) +
  geom_errorbar(aes(ymin = value - error, ymax = value + error), width = .2, position = position_dodge(.9)) +
  facet_wrap(~Measure, scales = "free", labeller = label_both) + 
  labs(y="", title = "Queue strategy: No queue")
```

Results are exaggerated for the FCFS queue strategy.

```{r queue_fcfs, echo=F, message=F, fig.dim=c(8,3)*1.1}
results$simulation |> 
  filter(`Arrival rate distribution` == "uniform", 
                `Queue strategy` == "FCFS",
                `Number of UAVs` == "high") |> 
  tidyr::pivot_longer(cols = c(`Mean response`, Ploss), names_to = "Measure") |> 
  mutate(Measure = factor(Measure, levels = c("Mean response", "Ploss"))) |>
  group_by(Measure,`Arrival rate variance`,`Flight configuration`, `Number of UAVs`) |> 
  summarise(error = qt(.975, df = n() - 1)*sd(value)/sqrt(n()),
            value = mean(value)) |> 
  ggplot(aes(x = `Arrival rate variance`, y = value, fill = `Flight configuration`)) +
  geom_col(position = position_dodge(.9)) +
  geom_errorbar(aes(ymin = value - error, ymax = value + error), width = .2, position = position_dodge(.9)) +
  facet_wrap(~Measure, scales = "free", labeller = label_both) + 
  labs(y="", title = "Queue strategy: FCFS")
```

Looking at just the numbers we get for Ploss the following numbers for zoned and free-flight: no constraint.

```{r, echo = F, message = F}
results$simulation |> 
  filter(`Solution method` %in% c("wkm-swkm"),
         `Flight configuration` %in% c("Zoned", "Free-flight: no constraint")) |> 
  tidyr::pivot_longer(cols = c(`Mean response`, Ploss), names_to = "Measure") |>
  filter(Measure == "Ploss") |> 
  group_by(`Solution method`, `Queue strategy`, `Flight configuration`, Measure) |>
  summarise(value = mean(value)) |> 
  tidyr::pivot_wider(names_from = `Flight configuration`, values_from = value) |> 
  dplyr::select(-`Solution method`) |> 
  knitr::kable(format = "pipe")
```

When looking at mean response we see the following difference.

```{r, echo = F, message = F}
results$simulation |> 
  filter(`Solution method` %in% c("wkm-swkm"),
         `Flight configuration` %in% c("Zoned", "Free-flight: no constraint")) |> 
  tidyr::pivot_longer(cols = c(`Mean response`, Ploss), names_to = "Measure") |>
  filter(Measure == "Mean response") |> 
  group_by(`Solution method`, `Queue strategy`, `Flight configuration`, Measure) |>
  summarise(value = mean(value)) |> 
  tidyr::pivot_wider(names_from = `Flight configuration`, values_from = value) |> 
  dplyr::select(-`Solution method`) |> 
  knitr::kable(format = "pipe")
```

## Example with real data

To see how the methods presented apply to real data we include the following section.
From the R package `maxcovr` we found the York crime data set.
We have sampled demand points from this data set, to mimic the original distribution, and made solutions and simulations.

```{r}
# The results from the york data set are available here
york <- readRDS(system.file("extdata", "york_simulation_metadata.rds", package = "zav"))
```

When comparing the solution we can see that `wkm-swkm` achieve a lower TOT objective as compared to `ga-tot`.

```{r, echo = F, message=F, fig.dim=c(8,3)*1.1}
york |> 
  group_by(`Solution method`, `Arrival rate variance`, `Number of UAVs`) |> 
  summarise(sd = sd(TOT), TOT = mean(TOT)) |> 
  ggplot(aes(x = `Arrival rate variance`, y = TOT, group = `Solution method`, color = `Solution method`)) +
  geom_point() +
  geom_line() +
  facet_wrap(~`Number of UAVs`, labeller = label_both)
```

Comparing now utilization of UAVs in the simulations we see that with low number of UAVs, low arrival rate variance and FCFS queue strategy we have higher utilization with `ga-tot` as compared to `wkm-swkm`.

```{r, echo=F, message=F, fig.dim=c(8,6)*1.1}
york %>%
  select(`Solution method`,`Number of UAVs`, `Queue strategy`, `Arrival rate variance`, utilization) %>%
  tidyr::unnest(cols = utilization) %>%
  group_by(hours, `Solution method`, `Queue strategy`, `Arrival rate variance`, `Number of UAVs`) %>%
  summarise(min_util = min(utilization), max_util = max(utilization), mean_util = mean(utilization)) %>%
  ggplot(aes(x= hours, group = paste0(`Solution method`, `Queue strategy`))) +
  geom_line(aes(y = mean_util, linetype = `Queue strategy`, color = `Solution method`)) +
  # geom_ribbon(aes(ymin = min_util, ymax = max_util, fill = `Queue strategy`), alpha = .4) +
  scale_y_continuous(limits = c(0,.4)) +
  facet_wrap(`Number of UAVs`~`Arrival rate variance`, labeller = label_both)

```

We believe this could be due to `ga-tot` having to base locations sharing the dense part of the service area, where as `wkm-swkm` only have one base location covering the dense part of the area.

```{r, echo=F, message=F, fig.dim=c(8,3.5)*1.1}
clean_york <- function(york_solution) {
  if (grepl("GA", york_solution)) {
  solution <- readRDS(york_solution)

  solution$no_of_centers <- nrow(solution$centroids)

  solution$clusters <- solution$centroids %>%
    dplyr::mutate(`Cluster id` = dplyr::row_number())

  solution$instance <- solution$instance %>%
    dplyr::inner_join(solution$clusters %>% dplyr::select(-x,-y), by = "Centroid id") %>%
    dplyr::select(-`Centroid id`) %>%
    dplyr::mutate(`Centroid id` = as.character(`Cluster id`)) %>%
    dplyr::select(-`Cluster id`)

    return(solution)
  } else {
    return(readRDS(york_solution))
  }
}

york_solutions <- lapply(
  list.files("inst/extdata/york", full.names = T) %>% as.list(),
  clean_york
)

cowplot::plot_grid(
  plot_bases(york_solutions[[3]]) + ggtitle("ga-tot"),
  plot_bases(york_solutions[[7]]) + ggtitle("wkm-swkm")
)
```

Looking now at the mean response and ploss metrics from the simulation we see...

```{r york_simulation_metrics, echo=F, message=F, fig.dim=c(8,6)*1.1}
york |>
  tidyr::pivot_longer(cols = c(`Mean response`, Ploss), names_to = "Measure") |> 
  mutate(Measure = factor(Measure, levels = c("Mean response", "Ploss"))) |>
  group_by(Measure,`Arrival rate variance`, `Solution method`, `Number of UAVs`) |> 
  summarise(value = mean(value)) |> 
  ggplot(aes(x = `Arrival rate variance`, y = value, color = `Solution method`, group = paste0(`Measure`,`Solution method`))) +
  geom_point(alpha = .75) +
  geom_line(alpha = .75) +
  facet_grid(Measure~`Number of UAVs`, scales = "free", labeller = label_both)
```
